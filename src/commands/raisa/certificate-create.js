const { SlashCommandBuilder, PermissionFlagsBits, MessageFlags } = require('discord.js');
const { createCertificate } = require('../../../raisa/certificates');
const { sendLog } = require('../../util/logger');

module.exports = {
	data: new SlashCommandBuilder()
		.setName('certificate-create')
		.setDescription('Creates a RAISA certificate.')
		.addStringOption(option =>
			option
				.setName('description')
				.setDescription('A short description for the certificate')
				.setRequired(true))
		.addStringOption(option =>
			option
				.setName('certificate_id')
				.setDescription('Optional custom RAISA certificate ID to use instead of an autogenerated one')
				.setRequired(false))
		.addStringOption(option =>
			option
				.setName('appoint_rank')
				// make it so that appoint_rank is restricted autofilling to the following ranks based on user authentication (oAuth) from verification system:
				// based on roblox groups
				// main group (id:):
				// "SC-3", "SC-4", "SC-5", "OoTA"
				// ScD ranks (group id: ):
				// ranks here
				.setDescription('Role or rank that can appoint this certificate')
				.setRequired(false))
		.setDefaultMemberPermissions(PermissionFlagsBits.Administrator),

	async execute(interaction) {
		if (!interaction.inGuild()) {
			return interaction.reply({ content: 'This command can only be used in a server.', flags: MessageFlags.Ephemeral });
		}

		const description = interaction.options.getString('description', true);
		const appointRank = interaction.options.getString('appoint_rank', false);
		const customId = interaction.options.getString('certificate_id', false);

		try {
			await interaction.deferReply({ flags: MessageFlags.Ephemeral });
			const cert = await createCertificate({ description, appointRank, certificateId: customId });
			await sendLog({
				message: 'Certificate created',
				client: interaction.client,
				type: 'success',
				command: 'certificate-create',
				user: interaction.user.tag,
				guild: interaction.guild?.name,
				data: { certificateId: cert.certificateId, description, appointRank },
			});
			return interaction.editReply({ content: `Certificate created with ID ${cert.certificateId}.`, flags: MessageFlags.Ephemeral });
		}
		catch (error) {
			await sendLog({
				message: 'Error creating certificate',
				client: interaction.client,
				type: 'error',
				command: 'certificate-create',
				user: interaction.user.tag,
				guild: interaction.guild?.name,
				data: { error: error.message },
			});
			if (interaction.deferred || interaction.replied) {
				return interaction.editReply({ content: 'An error occurred while creating the certificate.', flags: MessageFlags.Ephemeral });
			}
			return interaction.reply({ content: 'An error occurred while creating the certificate.', flags: MessageFlags.Ephemeral });
		}
	},
};